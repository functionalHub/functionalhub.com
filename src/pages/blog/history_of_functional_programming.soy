---
title: "A bit of history about functional programming"
headTitle: "Functional programming blog and news"
description: "Our blog about functional programming"
keywords: "functional programming, blog, articles, news"
weight: 4
---

{namespace pageBlogHistoryOfFunctionalProgrammingIndex}

/**
 *
 */
{template .render}
  {call main.sidebar data="all" /}
	{call main.render data="all"}
		{param content kind="html"}
			{call .pageContent data="all" /}
		{/param}
		{param elementClasses: 'Blog' /}
	{/call}
{/template}


/**
 *
 */
{template .pageContent}
	<div class="container-full-height">
		<div class="container">
			// Header nav
			{call main.header data="all" /}
		</div>

		<div class="container bg-white">
			<div class="row">
				//New init
				<img class="img-fluided" src="/images/blog/hommer.png" />

				<div class="col-md-8 col-lg-6 mx-auto pb-4">
					<h1 class="display-4 mt-5 mb-4 text-center text-secondary">A bit of history about functional programming</h1>
					<p>In these days, it looks like functional programming is the new kid in town, something trendy and cool that you have to know. At least until the next cool thing arrives. But actually, functional programming is quite old. Probably older than you!</p>
					<p>Let's look back at the past, to the forefathers of computing, in order to understand the present, but also to be able to anticipate the future.</p>
					<p>Functional programming and imperative programming were born almost at the same time, at least the mathematical theories behing them. In the 30s, Alonzo Church defined <i>Lambda Calculus</i>, which is considered the theory behind functional programming. At the same time, Alan Turing defined his Turing Machine, which is in turn the theory that made imperative programming possible. It was a kind of clash of the titans. A perfect race to define the mathematical model to solve universal computability problems (what we call right now "programs").</p>
					<p>In the 50s, the race moved to the practical implementations of those theories. John Backus, an IBM employee, created FORTRAN as one of the first "high level" imperative programming languages. In the same years, John McCarthy created Lisp in the MIT, as a practical implementation of Lambda Calculus theory.</p>
					<p>So we can say that FORTRAN is the great-grandfather of all imperative programming languages, while Lisp can be considered the same ancestor of all functional programming languages.</p>
					<img class="img-fluid" src="https://gallery.mailchimp.com/8f33dd73453553d27fb4d0fe8/images/af043d11-ac22-413b-a089-4700e22095f3.jpg" />
					<p>But notice the context of both projects: in one hand, IBM wanted a language that solved a business problem, programmers productivity, while Lisp goals were quite different: solve complex computing problems, AI related mainly (yes, McCarthy is the father of the AI also)</p>
					<p>Both languages competed in the early days of the computer science. But the industry chose the winner quickly: computers (mainframes) where super expensive in those years, and people had to rent machine-time on demand (hello elastic cloud computing). Since the computing time was so expensive, it was critical to save the time wasted compiling and running wrong programs. And given that most of the code was written using punch cards or machine code, most of the programs contained several errors, so most of the computing time was wasted. And FORTRAN compiler were much faster than any other in those years, including the Lisp one. Backus created a super efficient compiler and most of the programmers started to move from machine code to FORTRAN, leaving Lisp (and functional programming) only for some specific problems related to symbolic computation and primitive AI research.</p>
					<img class="img-fluid" src="https://gallery.mailchimp.com/8f33dd73453553d27fb4d0fe8/images/20127c27-af47-4bb9-bbb2-df2bc9aa3a9e.jpeg" />
					<p>But something happened in 1977: Backus received the Turing Award, (which is considered the Nobel prize in computing) for his work in high-level programming languages and FORTRAN. But to everyone's surprise, Backus' Turing Award lecture was focused on how functional programming is the right way to go, instead of using imperative programming and languages like FORTRAN. It was an apology for creating FORTRAN and making imperative programming the standard de-facto in those years.</p>
					<p>But it was already too late: most of the industry were already using imperative programming because it was more profitable than functional programming. First generations of programmers were shaped around imperative programming ideas, Unix and C were the way-to-go, next generations of programmers followed that trail... and the rest is history.</p>
					<p>And this is the way we've arrived to these days, where somehow we all developers are sons of C and grandsons of FORTRAN... without choosing it. But what is socking is that we're still using the same programming model for the last 50 years, even though today's hardware allows us to use better paradigms. Why are we stuck in the past?</p>
					<p>In these years, some programmers out there are wondering: Isn't it today the right time to revisit that "old idea" of functional programming? In a world where compilers take seconds to complete their task, and complexity in software is probably the main challenge nowadays, wouldn't be functional programming a feasible approach to achieve better concurrency, testeability and maintainability?</p>
					<p>So, now you know that if you've learnt C, Pascal or Java it wasn't by coincidence!</p>
				</div>
				//New end
			</div>
		</div>
	</div>
{/template}