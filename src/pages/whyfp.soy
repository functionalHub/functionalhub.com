---
title: "Why FP?"
headTitle: "Why is functional programming important for your future?"
description: "Why is functional programming important for your future?"
keywords: "functional programming, future, career, trend, trendy"
weight: 1
---

{namespace pageWhyFPIndex}

/**
 *
 */
{template .render}
  {call main.sidebar data="all" /}
	{call main.render data="all"}
		{param content kind="html"}
			{call .pageContent data="all" /}
		{/param}
		{param elementClasses: 'WhyFP' /}
	{/call}
{/template}

/**
 *
 */
{template .pageContent}
	<div class="container-full-height">
		<div class="container">
			// Header nav
			{call main.header data="all" /}
		</div>

		<div class="container bg-white">
			<div class="row">
				//New init
				<div class="col-md-8 col-lg-6 mx-auto pb-4">
					<h1 class="display-4 mt-5 mb-4 text-center text-secondary">Why FP?</h1>

					<p>Hola de nuevo! üëãüèª</p>

					<p>Aunque as√≠ lo parezca, me temo que la programaci√≥n no tiene nada de moda üíÖüèº, y mucho menos de "nueva"... en realidad la programaci√≥n funcional es muy vieja. Mucho m√°s que t√∫.</p>

					<p>Hoy vamos a mirar al pasado, a los pioneros de la inform√°tica, para entender el presente, y sobre todo, para ser capaces de anticiparnos al futuro. üîÆ</p>

					<p>La programaci√≥n funcional y la programaci√≥n imperativa nacieron al mismo tiempo, al menos a nivel te√≥rico, all√° por los a√±os 30. Mientras Alonzo Church defin√≠a su C√°lculo Lambda ∆õ, que es la base te√≥rica de la programaci√≥n funcional, Alan Turing hac√≠a lo propio con su M√°quina de Turing üé∞, que es a su vez la teor√≠a matem√°tica sobre la que se basa la programaci√≥n imperativa. Era un duelo de titanes, para ver quien defin√≠a el modelo te√≥rico (a nivel matem√°tico) que mejor pudiese resolver problemas computables universales (vamos, programas).</p>

					<p>Ya en los a√±os 50, la carrera se movi√≥ al plano m√°s pr√°ctico. John Backus, un trabajador de IBM, cre√≥ FORTRAN como implementaci√≥n real de ese modelo te√≥rico de computaci√≥n imperativa que defini√≥ Turing. M√°s o menos al mismo tiempo, en el MIT de Boston, John McCarthy hizo algo parecido creando Lisp, pero basado en el C√°lculo Lambda de Church. Otra vez la batalla estaba servida.</p>

					<p>Podr√≠amos decir que FORTRAN es el tatarabuelo de todos los lenguajes de programaci√≥n imperativos, y Lisp ocupa un lugar parecido para todos los lenguajes funcionales.</p>

					<img class="img-fluid" src="https://gallery.mailchimp.com/8f33dd73453553d27fb4d0fe8/images/af043d11-ac22-413b-a089-4700e22095f3.jpg" />

					<p>Es importante fijarse el contexto donde nacen ambos proyectos: por un lado IBM, que como empresa pura y dura, busca soluciones econ√≥micamente viables a problemas de sus clientes. Y por otro lado el MIT, que es el laboratorio donde se conciben las ideas m√°s revolucionarias y futuristas del mundo. Esto es importante tenerlo en cuenta ü§î</p>

					<p>Durante a√±os, ambos lenguajes compitieron por liderar la incipiente industria de la inform√°tica.
					Sin embargo, un "peque√±o detalle" hizo inclinar la balanza: las m√°quinas eran car√≠simas en aquellos a√±os, as√≠ que se programaba con papel y boli, y luego se alquilaban una m√°quina por horas (cloud computing?) para que alguien, normalmente una se√±orita (s√≠ amigos, las mujeres fueron las primeras programadoras üë©üèª‚Äçüíª), introdujese el programa en el ordenador, lo compilase y lo ejecutase, imprimiendo el resultado con una impresora matricial üñ®</p>

					<p>Lo que inclin√≥ la balanza fue que un programa escrito en FORTRAN (con estilo imperativo), se compilaba y ejecutaba infinitamente m√°s r√°pido que el mismo programa escrito en Lisp (con estilo funcional). Backus hab√≠a hecho un compilador muy eficiente para la √©poca, ya que a IBM le preocupaba, y mucho, el aspecto econ√≥mico üí∏
					Ponte en su lugar: si tu programa en estilo imperativo tarda minutos en compilarse, pero el mismo programa en estilo funcional tarda horas o hasta d√≠as, y tienes que pagar por ese tiempo de procesamiento, t√∫ tambi√©n dejar√≠as de lado el estilo funcional ¬øverdad? ü§ë</p>

					<p>As√≠ que en los siguientes a√±os, Lisp se fue dejando como la herramienta para resolver problemas especialmente complejos (como la inteligencia artificial), donde la rentabilidad econ√≥mica no era tan importante como conseguir una soluci√≥n a tu problema.</p>

					<img class="img-fluid" src="https://gallery.mailchimp.com/8f33dd73453553d27fb4d0fe8/images/20127c27-af47-4bb9-bbb2-df2bc9aa3a9e.jpeg" />

					<p>Y llegamos al a√±o 1977, donde Backus recibi√≥ el premio Turing (el Nobel de los inform√°ticos) por su trabajo en el √°rea de compiladores. Realmente el compilador de FORTRAN era muy bueno y avanzado.
					Pero para sorpresa de todos, en su discurso de la entrega del premio, en vez de sacar pecho, lo que hizo fue criticar duramente a los lenguajes imperativos y present√≥ a los lenguajes funcionales como la alternativa correcta. ¬°Estaba entonando un mea-culpa, tirando por tierra su propia creaci√≥n, por la que le estaban dando su premio m√°s importante! üòµ</p>

					<p>Pero ya era tarde: la industria ya hab√≠a elegido el camino m√°s rentable y pragm√°tico, las primeras generaciones de programadores se hab√≠an forjado en el modelo imperativo (recuerda, el √∫nico viable para el hardware de la √©poca), Unix y sus heroes, marcaron la pauta a partir de aquellos a√±os, C se volvi√≥ el lenguaje de referencia... y el resto ya es historia.</p>

					<p>Y as√≠ hemos llegado hasta el d√≠a de hoy, donde, en cierta manera, todos los desarrolladores actuales somos hijos de C y nietos de FORTRAN, pero sin haberlo elegido. Lo que resulta llamativo es que ya no tenemos esas restricciones de hardware, pero seguimos utilizando un modelo de programaci√≥n propio de los a√±os 50. Es duro decirlo, pero es as√≠. üèö</p>

					<p>Y desde hace unos cuantos a√±os, muchos programadores se est√°n haciendo la misma pregunta... ¬øno es el momento ya de retomar esa ‚Äúvieja idea‚Äù de la programaci√≥n funcional? Todos sabemos lo inmanejables que se vuelven los proyectos de software cuando crecen... y eso no deber√≠a ser as√≠. La programaci√≥n funcional aporta muchas ventajas a la hora de resolver problemas muy actuales, como el crecimiento y mantenimiento del software, o la ejecuci√≥n de c√≥digo as√≠ncrono, en paralelo o de forma concurrente, y nuestro hardware es capaz de compilar en segundos cualquier programa en estilo funcional üèÉ</p>

					<p>As√≠ que ahora ya sabes por qu√© aprendiste a programar en C, Pascal o Java, no fue por casualidad‚Ä¶ ma√±ana te contar√© m√°s sobre lo que te est√°s perdiendo por no usar programaci√≥n funcional.</p>

					<p>Y recuerda ¬°el viernes un regalo para t√≠! üéÅ</p>
				</div>
				//New end
			</div>
		</div>
	</div>
{/template}